/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

// This code reads PA0 and lights up PD12 LED if there is voltage going through PA0

#include <stdint.h>

int main(void)
{
	//addresses
    uint32_t volatile *const pClkControl = (uint32_t*) 0x40023830;
    uint32_t volatile *const pGpioAMode = (uint32_t*) 0x40020000;

    //Input register data is const b/c we don't want the programmer to change anything, yet it is volatile b/c it can still change externally
    //In this case, the pin may suddenly get voltage applied to it
    uint32_t const volatile *const pGpioAInputRead = (uint32_t*) 0x40020010;

    uint32_t volatile *const pGpioDMode = (uint32_t*) 0x40020C00;
    uint32_t volatile *const pGpioDOutputData = (uint32_t*) 0x40020C14;


    //enables AHB1ENR clock
    *pClkControl |= (1<<3);
    *pClkControl |= 1;

    //clear GPIO A0 mode then set to input mode
    *pGpioAMode &= ~(3);

    //clear GPIO D12 mode then set to general purpose output mode
    *pGpioDMode &= ~(3<<24);
    *pGpioDMode |= (1<<24);

    while(1)
    {
    	// to get pin status, we use a mask to only read the one bit we need instead of the 32bits the register provides.
    	uint8_t volatile pinStatus = (uint8_t) *pGpioAInputRead &0x1;
    	if(pinStatus == 1)
    		*pGpioDOutputData |= (1<<12);
    	else
    		*pGpioDOutputData &= ~(1<<12);
    }
}
