/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

// This program reads a 4x4 keypad matrix and prints the button pressed
#include <stdint.h>
#include <stdio.h>


void delay(void);

int main(void)
{
	SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));
	uint32_t volatile *const pClkControl = (uint32_t*) 0x40023830;
    uint32_t volatile *const pGpioDMode = (uint32_t*) 0x40020C00;
    uint32_t volatile *const pGpioDOutputData = (uint32_t*) 0x40020C14;
    uint32_t const volatile *const pGpioDInputRead = (uint32_t*) 0x40020C10;
    uint32_t volatile *const pPUPDRGpioD = (uint32_t*) 0x40020C0C;

    //enables AHB1ENR clock for Gpio D
    *pClkControl |= (1<<3);

    //Clear Mode for PD 3 2 1 0 then set to Output mode, these are the rows for keypad matrix
    *pGpioDMode &= ~(0xFF);
    *pGpioDMode |= 0x55;

    //Clear Mode for PD 11 10 9 8 to make sure they are in input mode, these are the columns of the matrix
    *pGpioDMode &= ~(0xFF<<16);

    //Clear Pull up pull down resistors for inputs, then set them to pull up mode
    *pPUPDRGpioD &= ~(0xFF<<16);
    *pGpioDMode |= (0x55<<16);


    //infinite loop
    while(1){
    	//Set all rows to HIGH
    	*pGpioDOutputData |= 0xF;

    	//We will make Row1 (PD0) to be a low state, and then read the columns. Whichever column is also low,
    	//than that is the button pressed
    	*pGpioDOutputData &= ~(1);

    	if(!(*pGpioDInputRead & (1<<8)))  //PD8
    	{
    		delay();
    		printf("1\n");
    	}
    	if(!(*pGpioDInputRead & (1<<9)))  //PD9
    	{
    		delay();
    		printf("2\n");
    	}
    	if(!(*pGpioDInputRead & (1<<10)))  //PD10
    	{
    		delay();
    	   	printf("3\n");
    	}

    	if(!(*pGpioDInputRead & (1<<11)))  //PD11
    	{
    		delay();
      		printf("A\n");
    	}

    	//Set all rows back to high, then make row2 (PD1) low
    	*pGpioDOutputData |= 0xF;
    	*pGpioDOutputData &= ~(1<<1);


    	if(!(*pGpioDInputRead & (1<<8)))  //PD8
    	{
    		delay();
    		printf("4\n");
    	}
    	if(!(*pGpioDInputRead & (1<<9)))  //PD9
    	{
    		delay();
    		printf("5\n");
    	}
    	if(!(*pGpioDInputRead & (1<<10)))  //PD10
    	{
    		delay();
    	   	printf("6\n");
    	}

    	if(!(*pGpioDInputRead & (1<<11)))  //PD11
    	{
    		delay();
      		printf("B\n");
    	}

    	//Set all rows back to high, then make row3 (PD2) low
    	*pGpioDOutputData |= 0xF;
    	*pGpioDOutputData &= ~(1<<2);


    	 if(!(*pGpioDInputRead & (1<<8)))  //PD8
       	{
    		delay();
    		printf("7\n");
    	}
    	if(!(*pGpioDInputRead & (1<<9)))  //PD9
    	{
    		delay();
    		printf("8\n");
      	}
      	if(!(*pGpioDInputRead & (1<<10)))  //PD10
      	{
      		delay();
      	   	printf("9\n");
      	}
    	if(!(*pGpioDInputRead & (1<<11)))  //PD11
    	{
    		delay();
      		printf("C\n");
    	}


    	//Set all rows back to high, then make row4 (PD3) low
    	*pGpioDOutputData |= 0xF;
    	*pGpioDOutputData &= ~(1<<3);


    	 if(!(*pGpioDInputRead & (1<<8)))  //PD8
       	{
    		delay();
    		printf("*\n");
    	}
    	if(!(*pGpioDInputRead & (1<<9)))  //PD9
    	{
    		delay();
    		printf("0\n");
      	}
      	if(!(*pGpioDInputRead & (1<<10)))  //PD10
      	{
      		delay();
      	   	printf("#\n");
      	}
    	if(!(*pGpioDInputRead & (1<<11)))  //PD11
    	{
    		delay();
      		printf("D\n");
    	}




    }


}

void delay(void)
{
	for(uint32_t i=0; i < 300000; i++);
}
